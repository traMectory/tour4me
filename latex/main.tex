%%
%% This is file `sample-acmsmall-biblatex.tex',
%% generated with the docstrip utility.
%%
%% The original source files were:
%%
%% samples.dtx  (with options: `acmsmall-biblatex')
%% 
%% IMPORTANT NOTICE:
%% 
%% For the copyright see the source file.
%% 
%% Any modified versions of this file must be renamed
%% with new filenames distinct from sample-acmsmall-biblatex.tex.
%% 
%% For distribution of the original source see the terms
%% for copying and modification in the file samples.dtx.
%% 
%% This generated file may be distributed as long as the
%% original source files, as listed above, are part of the
%% same distribution. (The sources need not necessarily be
%% in the same archive or directory.)
%%
%%
%% Commands for TeXCount
%TC:macro \cite [option:text,text]
%TC:macro \citep [option:text,text]
%TC:macro \citet [option:text,text]
%TC:envir table 0 1
%TC:envir table* 0 1
%TC:envir tabular [ignore] word
%TC:envir displaymath 0 word
%TC:envir math 0 word
%TC:envir comment 0 0
%%
%%
%% The first command in your LaTeX source must be the \documentclass command.
\documentclass[sigconf,natbib=false]{acmart}


%%
%% \BibTeX command to typeset BibTeX logo in the docs
\AtBeginDocument{%
  \providecommand\BibTeX{{%
    Bib\TeX}}}

%% Rights management information.  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.
\setcopyright{acmcopyright}
\copyrightyear{2018}
\acmYear{2018}
\acmDOI{XXXXXXX.XXXXXXX}


%%
%% These commands are for a JOURNAL article.
\acmJournal{JACM}
\acmVolume{37}
\acmNumber{4}
\acmArticle{111}
\acmMonth{8}

%%
%% Submission ID.
%% Use this when submitting an article to a sponsored event. You'll
%% receive a unique submission ID from the organizers
%% of the event, and this ID should be used as the parameter to this command.
%%\acmSubmissionID{123-A56-BU3}

%%
%% For managing citations, it is recommended to use bibliography
%% files in BibTeX format.
%%
%% You can then either use BibTeX with the ACM-Reference-Format style,
%% or BibLaTeX with the acmnumeric or acmauthoryear sytles, that include
%% support for advanced citation of software artefact from the
%% biblatex-software package, also separately available on CTAN.
%%
%% Look at the sample-*-biblatex.tex files for templates showcasing
%% the biblatex styles.
%%


%%
%% The majority of ACM publications use numbered citations and
%% references, obtained by selecting the acmnumeric BibLaTeX style.
%% The acmauthoryear BibLaTeX style switches to the "author year" style.
%%
%% If you are preparing content for an event
%% sponsored by ACM SIGGRAPH, you must use the acmauthoryear style of
%% citations and references.
%%
%% Bibliography style
\RequirePackage[
  datamodel=acmdatamodel,
  style=acmauthoryear,
  ]{biblatex}

%% Declare bibliography sources (one \addbibresource command per source)
\addbibresource{software.bib}
\addbibresource{sample-base.bib}
\usepackage{xspace}
\newcommand{\greedy}{\textsc{Greedy Selection}\xspace}
\newcommand{\jogging}{\textsc{Jogging Tour}\xspace}
\newcommand{\ils}{\textsc{Iterative Local Search}\xspace}
\newcommand{\ilp}{\textsc{Integer Linear Programming}\xspace}
\newcommand{\AOP}{\textsc{AOP}\xspace}
\newcommand{\III}{\mathcal{I}}
%%
%% end of the preamble, start of the body of the document source.
\begin{document}

%%
%% The "title" command has an optional parameter,
%% allowing the author to define a "short title" to be used in page headers.
\title{Tour4Me: A Framework for Customized Tour Planning Algorithms}

%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.

\author{Kevin Buchin}
\orcid{1234-5678-9012}
\affiliation{%
  \institution{TU Dortmund}
  \city{Dortmund}
  \country{Germany}
}
\email{kevin.buchin@tu-dortmund.de}

\author{Mart Hagedoorn}
\orcid{1234-5678-9012}
\affiliation{%
  \institution{TU Dortmund}
  \city{Dortmund}
  \country{Germany}
}
\email{mart.hagedoorn@tu-dortmund.de}

\author{Guangping Li}
\orcid{1234-5678-9012}
\affiliation{%
  \institution{TU Dortmund}
  \city{Dortmund}
  \country{Germany}
}
\email{guangping.li@tu-dortmund.de}

%%
%% By default, the full list of authors will be used in the page
%% headers. Often, this list is too long, and will overlap
%% other information printed in the page headers. This command allows
%% the author to define a more concise list
%% of authors' names for this purpose.
\renewcommand{\shortauthors}{Buchin, Hagedoorn, and Li}
\newcommand{\tG}{\textsc{Tour4Me}\xspace}

%%
%% The abstract is a short summary of the work to be presented in the
%% article.
\begin{abstract}
<<<<<<< HEAD
The touring problem aims to find an `interesting' (round) trip of a given length. Here, what is considered interesting depends on the type of the desired route, e.g., a user may be looking for a off-road cycling trip or fast running route.
There are two main perspectives on the touring problem, maximizing profit or minimizing cost, which result in very different algorithmic solutions. We provide a framework that allows for straightforward integration of new algorithms for both perspectives on the touring problem.
In this demonstration we have included a new exact solver, a heuristic, and two greedy methods. The user can experiment with the algorithms and different profits/costs. The generated tours can be explored in an easy-to-use web interface.
=======
In this demonstration paper we provide a framework that allows for straightforward integration of new algorithms for the touring problem. 
The touring problem aims to find an `interesting' tour of a given length, an user decides what is considered interesting.
There are two main approaches for the touring problem: maximizing attributes or minimizing cost.
We provide a framework that allows for straightforward integration of new algorithms for both approaches on the touring problem. 
In this demonstration we have included a new exact solver, a heuristic, and two greedy methods.
Furthermore, a GUI is provided in the form of a webpage, allowing for testing of algorithms, even by end users.
>>>>>>> d8fefa629fd1f14c230f98a1332e24075728464e
\end{abstract}

%%
%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
%% Please copy and paste the code instead of the example below.
%%
\begin{CCSXML}
<ccs2012>
 <concept>
  <concept_id>10010520.10010553.10010562</concept_id>
  <concept_desc>Computer systems organization~Embedded systems</concept_desc>
  <concept_significance>500</concept_significance>
 </concept>
 <concept>
  <concept_id>10010520.10010575.10010755</concept_id>
  <concept_desc>Computer systems organization~Redundancy</concept_desc>
  <concept_significance>300</concept_significance>
 </concept>
 <concept>
  <concept_id>10010520.10010553.10010554</concept_id>
  <concept_desc>Computer systems organization~Robotics</concept_desc>
  <concept_significance>100</concept_significance>
 </concept>
 <concept>
  <concept_id>10003033.10003083.10003095</concept_id>
  <concept_desc>Networks~Network reliability</concept_desc>
  <concept_significance>100</concept_significance>
 </concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Computer systems organization~Embedded systems}
\ccsdesc[300]{Computer systems organization~Redundancy}
\ccsdesc{Computer systems organization~Robotics}
\ccsdesc[100]{Networks~Network reliability}

%%
%% Keywords. The author(s) should pick words that accurately describe
%% the work being presented. Separate the keywords with commas.
\keywords{datasets, neural networks, gaze detection, text tagging}

%%
%% This command processes the author and affiliation and title
%% information and builds the first part of the formatted document.
\maketitle

\section{Introduction}

% Problem description and motivation
Most people who do outdoor activities run into the problem of finding an appropriate route. 
Depending on the activity from hiking and jogging to gravel and road cycling, requirements from individual users can greatly vary.
To this end we developed the framework \tG for computing customized round trip. 
The tool \tG includes four touring algorithms and provides an intuitive web interface to create tours customed to users specific demands and preferences. 
In this work, we introduce the touring problem, which is defined formally as follows. 
Let $G$ be a directed graph consisting a vertex set $V$ and a set $E$ of arcs. A cost function $w:E \rightarrow \mathbb{N}$ and a profit function $\pi: E \rightarrow \mathbb{N}$ assign different cost and profit to each arc of $G$.
We generalize the terms cost and profit to paths. Given a path $P = (e_1, \dots, e_{\ell})$ of $G$, we denote the cost of $P$ as $w(P)$, which is defined as $\sum_{i=1}^{\ell} w(e_i)$;we write $\pi(P) = \sum_{ e \in {\{e_1, \ldots e_l\}} } \pi(e)$ for the profit of $P$.  
Given a cost budget $B$ and a starting vertex $s$, the objective of touring problem is to find a cycle $P=(e_1, \dots, e_{\ell})$ starting and ending at the vertex $s$ that maximizes the profit sum within the cost budget $B$. 
Note that in the touring problem it is allowed to visit an edge multiple times, but its profit is only counted once. 
\subparagraph*{\textbf{Related Work.}}
In the orienteering problem (OP), given an (un)-directed graph, the goal is to find a path which maximizes the total collected profit while not violating the budget constraint. In the classic model, a cost is assigned to each edge/arcs and a profit is assigned to each vertex. The profit of a path is defined by the sum of collected profit of its visited vertices. 
The orienteering problem is well-studied since decades and finds applications in the fields . 
Motivated by cycling routing problem, the variant arc orienteering problem (\AOP) was introduced and has been studied in. In this variant, the profit is assigned to each edge and the profit of a path is defined by the sum of collected profits of each visited edge.
The touring problem is a variant of the  arc orienteering problem where the goal is to find a cycle with a fixed starting point. 


\subparagraph*{\textbf{Contribution.}}
Our contribution is twofold. We designed a prototype tool \tG for generating customized round trip. Here the user can give their priorities and preferences of road types and then the selected algorithm will compute a round trip with customized weights and profits; see Section~\ref{sec:system}. In this framework, we implemented four algorithms for touring problems; see Section~\ref{sec:algo}.
We selected one simple greedy approach, two representative sophisticated heuristics for \AOP problem and one exact solver based on our introduced (ILP) model for the touring problem.
\section{System}
\label{sec:system}
\subparagraph*{\textbf{Architecture.}}
Our framework is a one-page web application. For the implementation of efficient algorithms in back-end, we use C++. To display the computed routs in the map, our web interface uses the JavaScript library \href{https://leafletjs.com/}{\emph{Leaflet}}\footnote{\url{https://leafletjs.com/}} 
(version x.x.x). say something about the requirements sending....
\subparagraph*{\textbf{Data.}}

\subparagraph*{\textbf{Interface.}}
The user interface. shown in Fig., consists of a large background map. The starting point can selected by clicking on a spot directly in the map. 
say something about the toolbox and the workflow... 
%\begin{figure}[htb]
%\centering
%\includegraphics[width=\textwidth]{figs/guis}
%$\caption{The graphical user interface of the developed prototype.}
%\label{fig:GUI}		
%\end{figure}
\section{Algorithm}
\label{sec:algo}
We implemented four representative algorithms in our framework. The simplest approach \greedy is a fast greedy approach which selects edges of high profits.
The second greedy algorithm \jogging aims to obtain a cycle consisting of edges of low costs.  
The two sophisticated algorithms \ils and \ilp support area maximization. 
The algorithm \ils starts with the greedy solution computed by \greedy and improve the initial solution by an iteratve local search based metaheuristic, which also gives the name to our algorithm.
Finally, we introduce the exact solver \ilp for  the touring problem. As the name suggests, we formulate the touring problem as a  linear integer programming problem. 	
To solve our ILP formulation we use one of the state-of-the-art solver \href{https://www.gurobi.com/}{GUROBI} for mathematical programming. %
     
\subparagraph*{\textbf{Greedy Selection.}}
The greedy approach \greedy computes a cycling starting at the vertex $s$ by iteratively picking edges of the highest profit. To make sure the computed path is a valid cycle, we only pick edges, from whose endpoint the vertex $s$ can be reached by the remaining cost budget. We call such edges as valid candidates. 
It starts by picking an valid edge starting at $s$ of the highest profit. 
Next, we update the remaining cost budget and repeat this greedy selection from the endpoint of the new selected edge until reaching the starting vertex $s$ or reaching a vertex with no adjacent valid edge. 
If the process terminates at a vertex $v$ other than $s$, we add the shorted path from $v$ to $s$ to the computed solution. 
        

\subparagraph*{\textbf{Jogging Tour.}}
We further selected one representative existing approach \jogging~\cite{DBLP:conf/wea/GemsaPWZ13} for the \AOP problem.  (something goes wrong with the bibtex)
In contract to \greedy approach, this approach takes the edge costs into account and  tries to select the ``efficient'' edges, that are edges of high profit and low cost. 
For this, we introduce the metric \textsc{Inefficiency} \xspace on the edges $\gamma: E-> R_{+}$. For each edge $e \in E$, we set $\gamma(e) = \frac{w(e)}{\pi(e) + 0.1}$.
Intuitively, this approach aims to obtain an equilateral triangles consisting of three efficient paths, each of which has a cost close to  $\frac{B}{3}$, and having $s$ as one of the triangle's edge. Firstly, we run a shortest path computation (with Dijkstraâ€™s algorithm) from $s$
using this metric inefficiency.
For each vertex $u,v$, we refer to $P_{u,v}$ as the shortest path of the metric inefficiency in the following.   
We now determine the vertices whose shortest path from $s$ has cost in the range $[\frac{B}{3}- \frac{B}{10} , \frac{B}{3} + \frac{B}{10}]$. We refer to the set of such candidate vertices as the \textit{ring} of $s$ $R_s$.
Next, for each candidate vertex $v$ of $s$, we run a shortest path computation from $v$ and compute the ring $R_v$. Now, we consider the intersection $I_{s,v}$ of two ring sets $R_s$ and $R_v$. Note that the distances from each vertex $u\in I_{s,v}$ to $s$ and $u$ are in the range $[\frac{B}{3}- \frac{B}{10} , \frac{B}{3} + \frac{B}{10}]$. Then, we check whether the concatenation of the paths $P_{s,v}, P_{v,u}$ and $P_{v,u}$ is a valid solution, i.e., the cost of the computed cycling is bounded by the cost budget $B$. 
We repeat this step for each vertex in the ring $R_s$ and collect a set of candidate cycles. 
Finally, we pick the candidate solution with the highest profit as the final solution.
Note that this algorithm may not find any feasible solution.
       

\subparagraph*{\textbf{Iterative Local Search.}}
The \ils algorithm is modified from the iterative local search approach proposed for \AOP problem, which is proposed in~\cite{} and proved to be efficient for real-life instances. 
The local search \ils runs the \greedy approach and starts with the the computed solution as the initial solution.
In order to escape form local minima, in each step of improvement phase, the current solution is modified by removing a different partial path. Then, a local movement is applied to connect the endpoints in the current solution and increase the total profit.
The partial path for removal is determined by two parameters $p$ and $l$, where $i$ indicates the position of the current solution to start the removal and $l$ is the length of the path to remove. 
Both parameters are set to $1$ at the start and increased by $1$ in every iteration. The parameter $p$ is reset to $1$ if the removal reaches the starting vertex $s$ and $l$ is reset to $1$ if $l$ reached the length of the whole solution.     
After removing the path $P$ from a vertex $u$ to a vertex $v$ in the current solution $S$, we aim to find a better path between $u$ and $v$ which provides higher profit and whose cost is bound by the remaining cost budget, i,e, $B- w(S\setminus P)$.    
The basic idea applied here is a depth first search. To accelerate the local move, we use a parameter $D$ to restrict the depth of the search. The search starts from  the vertex $u$ and explore at most $D$ depth along each branch. Once a path $P'$ reaching the vertex $v$  without violating the budget constraint is found, we check if the total profit of the current solution is increased by replacing $P$ by $P'$. 
If so, we stop the search and update the current solution. 
  
 

\subparagraph*{\textbf{Integer Linear Programming.}}
Finally, we introduce the exact solver \ilp for  the touring problem. As the name suggests, we formulate the touring problem as an integer linear programming problem. 	
To solve our ILP formulation we use one of the state-of-the-art solver  \href{https://www.gurobi.com/}{GUROBI} for mathematical programming. 
We now encode an instance $\III = (G, w, \pi, B, v_0)$ of touring problem, where $v_0$ is the starting vertex, into the ILP formulation as follows.
We first introduce a canonical type of solutions produced by our solver.
Note that a valid solution cycle consists of at most $L :=\frac{B}{w_{min}}$ edges, where $B$ is the cost budget and $w_{min}$ is the minimum cost of an edge of $G$.
Thus, given any cycle $P = (v_0, \ldots, v_i, \ldots v_0)$ of a length bounded by $L$ , we could always extend $P$ to a cycle $P'$ of length exact $L$ by appending extra $v_0$ in the end. 
Note that, the path $P'$ has the same cost and profit as $P$. 
We call such cycle  $P'$ of length $L$ and starting from the vertex $v_0$ as the canonical cycle in the following. 
\subparagraph*{\textbf{Variables.}}
For each edge $v_iv_j \in E$, we introduce the variable $b_ij$($= 1$ if $v_iv_j$ is part of the solution; $0$ otherwise), $n_ij$ (the number of $v_iv_j$ in the solution) and $p_{kij}$($= 1$ if $v_iv_j$ $k$th edge of the solution; $0$ otherwise) for $k\in [1, 2, \ldots, L]$. 
For each vertex $v_i \in V$, we introduce the variable $p_{qi}$. 
If $p_{qi}$ is $1$, that means $v_i$ is the $k$th vertex of the solution path for $q\in [1, 2, \ldots, L+1]$; otherwise $p_{qi}$ is $0$.
\subparagraph*{\textbf{Constraints.}}
\begin{align}
	\forall v_iv_j\in E, \sum_{k \in [1, \ldots, L]}p_{kij} = n_{ij}\label{con1}\\
	\forall v_iv_j\in E, b_{ij} \leq n_{ij}\label{con2}\\
	\forall k \in [1, \ldots, L], \sum_{v_iv_j\in E}p_{kij} = 1\label{con3}\\
	\forall q \in [1, \ldots, L+1], \sum_{v_i\in V}p_{qi} = 1\label{con4}\\
	\forall v_iv_j\in E, p_{ki} + p_{(k+1)j} \geq 2 \times p_{kij}\label{con5}\\
	p_{10} = 1,  p_{(k+1)0} = 1\label{con6}\\
	\forall v_iv_j\in E, \sum_{v_iv_j\in E} w(v_iv_j) \times n_{ij} \leq B\label{con7}
\end{align}
The constraint~\eqref{con1} specifies that the $n_{ij}$ is the number of the edge $v_iv_j$ in the solution rout and the constraint~\eqref{con2} enforces that $b_ij$ is $0$ if $n_{ij}$ is $0$.
The constraints ~\eqref{con3}, ~\eqref{con4} and  ~\eqref{con5} guarantee the validity of the solution path and the constraint  ~\eqref{con6} guarantees that the solution is a cycle starting and ending at vertex $v_0$.
Finally, the constraint~\eqref{con6} states that the computed solution has cost bounded by the cost budget. 
\section{Conclusion}

% \begin{tabular}{rl}
%   $s$ & part of the input, start vertex\\
%   $t$ & part of the input, target vertex\\
%   $B$ & part of the input, the budget of the tour.\\
%   $c_{ij}$ & cost of traveling over edge $e_{ij}$.\\
%   $\pi_{ij}$ & profit of traveling over edge $e_{ij}$.\\\\
%   $b_{ij}$ & binary value for every edge $e_{ij}$, assume that $i < j$.\\
%   $n_{ij}$ & number of times that the edge $e_{ij}$ is included in the path.\\
%   $p_{ki}$ & true if $v_i$ is in position $k$.
% \end{tabular}

% \begin{equation*}
% \begin{array}{lr@{}ll}
% \text{maximize}  & \displaystyle\sum\limits_{e_{ij} \in E} \pi_{ij}b_{ij} & &\\\\
% \text{subject to}& \displaystyle\sum\limits_{e_{ij} \in E}   c_{ij}b_{ij} & \leq B  &\\
%                &                                         b_{ij}  & \leq  &\forall e_{ij} \in E\\
%                &                                          n_{ij} &\in \{0, \cdots, B\}, &\forall e_{ij} \in E
% \end{array}
% \end{equation*}

% \printbibliography

\end{document}
\endinput
%%
%% End of file `sample-acmsmall-biblatex.tex'.